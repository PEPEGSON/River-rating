/** =========================
 * River Rating – Sync Sxx -> Matches
 * ========================= */

const CFG = {
  SHEET_PLAYERS: 'Players',
  SHEET_MATCHES: 'Matches',
  SHEET_GAMES: 'Games',
  CACHE_META_SEC: 120,
  CACHE_DASH_SEC: 60,

  // где в S01 находятся имена/даты
  S_NAME_COL: 2,     // B
  S_HEADER_ROW: 1,   // 1
  S_FIRST_PLAYER_ROW: 2, // 2
  S_FIRST_DATE_COL: 3,   // C
};

function doGet(e) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const mode = (e && e.parameter && e.parameter.mode ? String(e.parameter.mode) : '').toLowerCase();
  const playerId = (e && e.parameter && e.parameter.player_id ? String(e.parameter.player_id) : '');
  const seasonId = (e && e.parameter && e.parameter.season_id ? String(e.parameter.season_id) : '');

  if (mode === 'meta') {
    return json_(getMeta_(ss));
  }

  if (mode === 'dashboard') {
    const sid = String(seasonId || '').trim();
    if (!sid) return json_({ error: 'season_id required' });

    const cache = CacheService.getScriptCache();
    const cacheKey = `dash_${sid.toUpperCase()}`;
    const cached = cache.get(cacheKey);
    if (cached) return json_(JSON.parse(cached));

    const dash = getDashboard_(ss, sid);
    cache.put(cacheKey, JSON.stringify(dash), CFG.CACHE_DASH_SEC);
    return json_(dash);
  }

  if (playerId) {
    const sid = String(seasonId || '').trim();
    return json_(getProfile_(ss, playerId, sid));
  }

  return json_({ ok: true, hint: 'use ?mode=meta or ?mode=dashboard&season_id=S01 or ?player_id=P001&season_id=S01' });
}

/** =========================
 * META / DASHBOARD
 * ========================= */

function getMeta_(ss) {
  const seasonsSheet = ss.getSheetByName('Seasons');
  const leaderboardSheet = ss.getSheetByName('Leaderboard');

  const current = String(leaderboardSheet && leaderboardSheet.getRange('G2').getValue() || '').trim();

  let seasons = [];
  if (seasonsSheet) {
    const v = seasonsSheet.getDataRange().getDisplayValues();
    const h = (v[0] || []).map(x => String(x).trim().toLowerCase());
    const idxId = h.indexOf('season_id');
    const idxName = h.indexOf('season_name');

    for (let i = 1; i < v.length; i++) {
      const row = v[i];
      const id = String(row[idxId] || '').trim();
      const name = String(row[idxName] || '').trim();
      if (id) seasons.push({ season_id: id, season_name: name || id });
    }
  }

  return { seasons, current_season_id: current || (seasons[0]?.season_id || '') };
}

function getDashboard_(ss, seasonId) {
  const sid = String(seasonId || '').trim().toUpperCase();

  const matches = readMatches_(ss, sid);

  // ВАЖНО: оставляем как было в твоём эталоне:
  // leaderboard собираем (как и раньше) через buildLeaderboardFromMatches_.
  // Если у тебя в реальном проекте leaderboard берётся из листа Leaderboard (с rank/achievements),
  // то он был в твоём “рабочем” коде, а не в этом “упрощённом эталоне”.
  // Здесь мы ничего НЕ вырезаем, чтобы не ломать структуру.
  const leaderboard = buildLeaderboardFromMatches_(ss, matches, sid);

  const season_table = readSeasonTableRaw_(ss, sid);

  return {
    season_id: sid,
    leaderboard,
    matches,
    season_table,
  };
}

/** =========================
 * SYNC: Sxx -> Matches
 * ========================= */

function rebuildMatchesForSeason(seasonId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  rebuildMatchesForSeason_(ss, String(seasonId || '').trim().toUpperCase());
  clearDashCache_(String(seasonId || '').trim().toUpperCase());
}

function onEdit(e) {
  try {
    if (!e || !e.range) return;

    const sh = e.range.getSheet();
    const name = sh.getName();
    if (!/^S\d+$/i.test(name)) return;

    const r = e.range.getRow();
    const c = e.range.getColumn();
    if (r < CFG.S_FIRST_PLAYER_ROW) return;
    if (c < CFG.S_FIRST_DATE_COL) return;

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sid = name.toUpperCase();

    rebuildMatchesForSeason_(ss, sid);
    clearDashCache_(sid);
  } catch (err) {
    console.error(err);
  }
}

function setupTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  const has = triggers.some(t => t.getHandlerFunction() === 'onEdit');
  if (!has) {
    ScriptApp.newTrigger('onEdit')
      .forSpreadsheet(SpreadsheetApp.getActiveSpreadsheet())
      .onEdit()
      .create();
  }
}

/** =========================
 * CORE: rebuild matches
 * (FIX) НЕ ЧИСТИМ ВЕСЬ Matches
 * а удаляем только строки нужного season_id
 * ========================= */

function rebuildMatchesForSeason_(ss, seasonId) {
  const sid = String(seasonId || '').trim().toUpperCase();

  const seasonSheet = ss.getSheetByName(sid);
  if (!seasonSheet) throw new Error(`Season sheet not found: ${sid}`);

  const mapNameToPlayerId = getPlayersMap_(ss);
  const mapDateToGameName = getGamesMap_(ss, sid);

  const lastRow = seasonSheet.getLastRow();
  const lastCol = seasonSheet.getLastColumn();
  if (lastRow < CFG.S_FIRST_PLAYER_ROW || lastCol < CFG.S_FIRST_DATE_COL) return;

  const data = seasonSheet.getRange(CFG.S_HEADER_ROW, 1, lastRow, lastCol).getDisplayValues();

  const headers = data[CFG.S_HEADER_ROW - 1] || [];
  const dateHeaders = [];

  for (let col = CFG.S_FIRST_DATE_COL - 1; col < headers.length; col++) {
    const ddmm = normalizeDdMm_(headers[col]);
    if (ddmm) dateHeaders.push({ colIndex: col, ddmm });
  }

  const newMatchesThisSeason = [];

  for (const d of dateHeaders) {
    const rowsForDay = [];

    for (let r = CFG.S_FIRST_PLAYER_ROW - 1; r < data.length; r++) {
      const name = String(data[r][CFG.S_NAME_COL - 1] || '').trim();
      if (!name) continue;

      const pid = mapNameToPlayerId[name];
      if (!pid) continue;

      const pts = toNum_(data[r][d.colIndex]);
      if (pts <= 0) continue;

      rowsForDay.push({ pid, pts, name });
    }

    rowsForDay.sort((a, b) => (b.pts - a.pts) || a.name.localeCompare(b.name, 'ru', { sensitivity: 'base' }));

    for (let i = 0; i < rowsForDay.length; i++) {
      const place = i + 1;
      const gameName = mapDateToGameName[d.ddmm] || '';
      newMatchesThisSeason.push([d.ddmm, sid, rowsForDay[i].pid, rowsForDay[i].pts, place, gameName]);
    }
  }

  const matchesSheet = ss.getSheetByName(CFG.SHEET_MATCHES) || ss.insertSheet(CFG.SHEET_MATCHES);

  // читаем текущие строки Matches, оставляем все сезоны кроме sid
  const kept = readMatchesKeepOtherSeasons_(matchesSheet, sid);

  // пересобираем лист
  matchesSheet.clearContents();

  const header = [['date', 'season_id', 'player_id', 'points', 'place', 'game_name']];
  matchesSheet.getRange(1, 1, 1, header[0].length).setValues(header);

  const out = kept.concat(newMatchesThisSeason);

  if (out.length) {
    matchesSheet.getRange(2, 1, out.length, header[0].length).setValues(out);
    matchesSheet.getRange(2, 4, out.length, 2).setNumberFormat('0');
  } else {
    matchesSheet.getRange(2, 4, 1, 2).setNumberFormat('0');
  }
}

function readMatchesKeepOtherSeasons_(matchesSheet, seasonIdToRemove) {
  const sid = String(seasonIdToRemove || '').trim().toUpperCase();

  const v = matchesSheet.getDataRange().getDisplayValues();
  if (!v || v.length < 2) return [];

  const h = (v[0] || []).map(x => String(x).trim().toLowerCase());
  const iSeason = h.indexOf('season_id');

  // если заголовок сломан — ничего не сохраняем (пересоздадим с нуля)
  if (iSeason < 0) return [];

  const kept = [];
  for (let r = 1; r < v.length; r++) {
    const row = v[r];
    const rowSid = String(row[iSeason] || '').trim().toUpperCase();
    if (rowSid && rowSid !== sid) kept.push(row);
  }
  return kept;
}

/** =========================
 * READ helpers
 * ========================= */

function readMatches_(ss, seasonId) {
  const sh = ss.getSheetByName(CFG.SHEET_MATCHES);
  if (!sh) return [];

  const v = sh.getDataRange().getDisplayValues();
  if (v.length < 2) return [];

  const h = v[0].map(x => String(x).trim().toLowerCase());
  const iDate = h.indexOf('date');
  const iSeason = h.indexOf('season_id');
  const iPid = h.indexOf('player_id');
  const iPts = h.indexOf('points');
  const iPlace = h.indexOf('place');
  const iGame = h.indexOf('game_name');

  const sid = String(seasonId || '').trim().toUpperCase();

  const out = [];
  for (let r = 1; r < v.length; r++) {
    const row = v[r];
    if (String(row[iSeason] || '').trim().toUpperCase() !== sid) continue;
    out.push({
      date: normalizeDdMm_(row[iDate]),
      season_id: String(row[iSeason] || '').trim(),
      player_id: String(row[iPid] || '').trim(),
      points: toNum_(row[iPts]),
      place: toNum_(row[iPlace]),
      game_name: String(row[iGame] || '').trim(),
    });
  }
  return out;
}

function readSeasonTableRaw_(ss, seasonId) {
  const sh = ss.getSheetByName(String(seasonId || '').trim().toUpperCase());
  if (!sh) return { headers: [], rows: [] };

  const v = sh.getDataRange().getDisplayValues();
  return {
    headers: v[0] || [],
    rows: v.slice(1),
  };
}

/** =========================
 * LEADERBOARD from matches
 * ========================= */

function buildLeaderboardFromMatches_(ss, matches, seasonId) {
  const pidToName = getPlayersMapReverse_(ss);

  const byPid = new Map();
  for (const m of matches) {
    const pid = m.player_id;
    if (!byPid.has(pid)) byPid.set(pid, { player_id: pid, name: pidToName[pid] || pid, season_score: 0 });
    byPid.get(pid).season_score += Number(m.points || 0);
  }

  const arr = [...byPid.values()].map(x => ({
    player_id: x.player_id,
    name: x.name,
    season_score: x.season_score,
    all_seasons_score: x.season_score,
    rank_level: 1,
    achievements: '',
    achievements_list: [],
  }));

  arr.sort((a, b) => (b.season_score - a.season_score) || a.name.localeCompare(b.name, 'ru', { sensitivity: 'base' }));
  return arr;
}

/** =========================
 * PROFILE (заглушка)
 * ========================= */
function getProfile_(ss, playerId, seasonId) {
  return {
    profile: [{ label: 'Имя', value: playerId }],
    medals: { top1: 0, top2: 0, top3: 0 },
    rank: { level: 1, title: 'Новичок' },
    achievements: [],
    history: [],
  };
}

/** =========================
 * MAPS
 * ========================= */

function getPlayersMap_(ss) {
  const sh = ss.getSheetByName(CFG.SHEET_PLAYERS);
  if (!sh) throw new Error('Players sheet not found');

  const v = sh.getDataRange().getDisplayValues();
  const h = v[0].map(x => String(x).trim().toLowerCase());
  const iPid = h.indexOf('player_id');
  const iName = h.indexOf('name');

  const map = {};
  for (let i = 1; i < v.length; i++) {
    const pid = String(v[i][iPid] || '').trim();
    const name = String(v[i][iName] || '').trim();
    if (pid && name) map[name] = pid;
  }
  return map;
}

function getPlayersMapReverse_(ss) {
  const sh = ss.getSheetByName(CFG.SHEET_PLAYERS);
  if (!sh) return {};

  const v = sh.getDataRange().getDisplayValues();
  const h = v[0].map(x => String(x).trim().toLowerCase());
  const iPid = h.indexOf('player_id');
  const iName = h.indexOf('name');

  const map = {};
  for (let i = 1; i < v.length; i++) {
    const pid = String(v[i][iPid] || '').trim();
    const name = String(v[i][iName] || '').trim();
    if (pid && name) map[pid] = name;
  }
  return map;
}

function getGamesMap_(ss, seasonId) {
  const sh = ss.getSheetByName(CFG.SHEET_GAMES);
  if (!sh) return {};

  const v = sh.getDataRange().getDisplayValues();
  const h = v[0].map(x => String(x).trim().toLowerCase());

  const iDate = h.indexOf('date');
  const iSeason = h.indexOf('season_id');
  const iGame =
    (h.indexOf('game_name') >= 0 ? h.indexOf('game_name') :
     (h.indexOf('game') >= 0 ? h.indexOf('game') :
      h.indexOf('name')));

  // если заголовки не найдены — просто не будет подстановки, но скрипт не упадёт
  if (iDate < 0 || iSeason < 0 || iGame < 0) return {};

  const sid = String(seasonId || '').trim().toUpperCase();

  const map = {};
  for (let i = 1; i < v.length; i++) {
    const rowSid = String(v[i][iSeason] || '').trim().toUpperCase();
    if (rowSid !== sid) continue;

    const ddmm = normalizeDdMm_(v[i][iDate]);
    const g = String(v[i][iGame] || '').trim();
    if (ddmm && g) map[ddmm] = g;
  }
  return map;
}

/** =========================
 * CACHE / UTILS
 * ========================= */

function clearDashCache_(seasonId) {
  const cache = CacheService.getScriptCache();
  cache.remove(`dash_${String(seasonId).trim().toUpperCase()}`);
}

function normalizeDdMm_(v) {
  if (v === null || v === undefined) return '';

  // если это Date object
  try {
    if (Object.prototype.toString.call(v) === '[object Date]' && !isNaN(v.getTime())) {
      return Utilities.formatDate(v, Session.getScriptTimeZone(), 'dd.MM');
    }
  } catch (e) {}

  const s0 = String(v).trim();
  if (!s0) return '';

  const s = s0.replace(/\s+/g, '');

  // dd.mm
  let m = s.match(/^(\d{1,2})\.(\d{1,2})$/);
  if (m) {
    const dd = String(m[1]).padStart(2, '0');
    const mm = String(m[2]).padStart(2, '0');
    return `${dd}.${mm}`;
  }

  // dd.mm.yyyy (или dd.mm.yy)
  m = s.match(/^(\d{1,2})\.(\d{1,2})\.(\d{2,4})$/);
  if (m) {
    const dd = String(m[1]).padStart(2, '0');
    const mm = String(m[2]).padStart(2, '0');
    return `${dd}.${mm}`;
  }

  // fallback: попытка вытащить первые dd.mm из строки
  m = s.match(/(\d{1,2})\.(\d{1,2})/);
  if (m) {
    const dd = String(m[1]).padStart(2, '0');
    const mm = String(m[2]).padStart(2, '0');
    return `${dd}.${mm}`;
  }

  return s0;
}

function toNum_(v) {
  const s = String(v ?? '').trim().replace(/\s+/g, '').replace(',', '.');
  const n = Number(s);
  return Number.isFinite(n) ? n : 0;
}

function json_(obj) {
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
